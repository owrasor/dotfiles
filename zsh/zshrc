# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

export ZSH="$HOME/.oh-my-zsh"
# ZSH_THEME="powerlevel10k/powerlevel10k"
HYPHEN_INSENSITIVE="true"
COMPLETION_WAITING_DOTS="true"
HIST_STAMPS="mm/dd/yyyy"
VI_MODE_SET_CURSOR=true
VI_MODE_RESET_PROMPT_ON_MODE_CHANGE=true

#Need this custom plugin to add artisan commands
#https://github.com/owrasor/zsh-artisan
plugins=(
    artisan
    npm
    composer
    cp
    dnf
    docker
    docker-compose
    git
    httpie
    rsync
    tmux
    z
    nvm
)

source $ZSH/oh-my-zsh.sh

#--------------------------------------------------------------------------
# Configuration
#--------------------------------------------------------------------------

# Decrease delay that vi-mode waits for the end of a key sequence
export KEYTIMEOUT=15

typeset -U path cdpath fpath
path=(
    $HOME/.local/bin
    $HOME/.config/composer/vendor/bin
    $HOME/.go/bin
    $HOME/.cargo/bin
    $HOME/App/PhpStorm-231.8109.199/bin
    ./vendor/bin
    ${ANDROID_HOME}tools/
    ${ANDROID_HOME}platform-tools/
    $path
)

setopt auto_cd
cdpath=(
    $HOME/Code
)

zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format %d
zstyle ':completion:*:descriptions' format %B%d%b
zstyle ':completion:*:complete:(cd|pushd):*' tag-order \
    'local-directories named-directories'

export EDITOR=vim
export GIT_EDITOR=vim
export ARTISAN_OPEN_ON_MAKE_EDITOR=nvr
export FZF_DEFAULT_COMMAND='ag -u -g ""'

unsetopt sharehistory

# -----------------------------------------------------------------------------
# ALIASES
# -----------------------------------------------------------------------------

# Artisan
alias a="artisan"
alias server="a serve"
alias horizon="a horizon"
alias mfs="a migrate:fresh --seed"
alias tinker="a tinker"
alias m="a migrate"
alias rl="a route:list"
alias horizon="a horizon"
alias key="a key:generate"
alias t="a test"
alias tp="a test --parallel"
alias tc="a test --compact"
alias pint="./vendor/bin/pint"
#
# Git
alias g="git"
alias gs="git s"
alias nah="git reset --hard;git clean -df"
alias co="git checkout"
alias main='git checkout $([ `git rev-parse --quiet --verify master` ] && echo "master" || echo "main")'
alias glg='git log --oneline --decorate --color --graph'
alias gclean='git branch --merged | grep -v "\*" | xargs -n 1 git branch -d'

# Docker
alias d="docker"
alias dc="docker compose"

#PHPSTORM
alias pstorm="phpstorm.sh"


# Composer
alias c="composer"
alias ci="composer install"
alias cu="composer update"
alias cdump="composer dump-autoload"

# Node & NPM
alias nd="npm run dev"
alias nf="npm run front"
alias ni="npm install"
alias nu="npm update"

# Minio
alias minio_serve="minio server ~/Code/minio"

# Takeout
alias takeout="docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --add-host=host.docker.internal:host-gateway -it tighten/takeout:latest"

#love
alias love="/Applications/love.app/Contents/MacOS/love"


# Create symbolic link to Herd
function unlink_herd() {
    project=$1
    full_directory=$(pwd)

    if [ -z "$project" ]; then
        project=$(basename "$PWD")
    fi

    eval "rm ~/Herd/$project/$full_directory"
}

# Create symbolic link to Herd
function link_herd() {
    project=$1
    full_directory=$(pwd)

    if [ -z "$project" ]; then
        project=$(basename "$PWD")
    fi

    eval "ln -s $full_directory ~/Herd/$project"
}

# Create symbolic proxy to Herd
function proxy_herd() {
    project=$1
    port=$2

    if [ -z "$project" ]; then
        project=$(basename "$PWD")
    fi

    if [ -z "$port" ]; then
        port=8081
    fi

    eval "herd proxy $project http://127.0.0.1:$port"
}

# Create symbolic proxy to Herd
function unproxy_herd() {
    project=$1

    if [ -z "$project" ]; then
        project=$(basename "$PWD")
    fi

    eval "herd unproxy $project"
}

# Create new host at /etc/hosts
function add_host() {
    if [ $# -ne 2 ]; then
        echo "Usaee: ah <ip_address> <hostname>"
        return 1
    fi

    local ip=$1
    local hostname=$2

    if [ -n "$(grep $hostname /etc/hosts)" ]; then
        echo "Hostname already exists in /etc/hosts"
        return 1
    fi

    echo "$ip $hostname" | sudo tee -a /etc/hosts >/dev/null

    if [ -n "$(grep $hostname /etc/hosts)" ]; then
       echo "Entry added to /etc/hosts"
    else
       echo "Entry failed to be added at /etc/hosts"
    fi
}

# function add_herd_aprova () {
#     if [ "$#" -ne 1 ]; then
#         echo "Usage: $0 domain.test"
#         echo "Example: $0 example.test"
#         return 1
#     fi
#
#     DOMAIN="$1"
#     NGINX_DIR="/Users/owrasor/Library/Application Support/Herd/config/valet/Nginx"
#     NEW_CONFIG="$NGINX_DIR/$DOMAIN"
#
#     # Check if the config already exists
#     if [ -f "$NEW_CONFIG" ]; then
#         echo "Error: Configuration for $DOMAIN already exists"
#         return 1
#     fi
#
#     # Create the new configuration
#     mkdir -p "$NGINX_DIR"
#     cat <<EOF | sed "s/demo\.aprovafacil\.test/$DOMAIN/g" > "$NEW_CONFIG"
# server {
#     listen 127.0.0.1:80;
#     server_name $DOMAIN www.$DOMAIN *.$DOMAIN;
#     root /;
#     charset utf-8;
#     client_max_body_size 1024M;
#
#     location /41c270e4-5535-4daa-b23e-c269744c2f45/ {
#         internal;
#         alias /;
#         try_files \$uri \$uri/;
#     }
#
#     access_log off;
#     error_log "/Users/owrasor/Library/Application Support/Herd/Log/$DOMAIN-error.log";
#
#     error_page 404 "";
#
#     location /vendor/horizon/ {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri \$uri/ /index.php\$is_args$args;
#     }
#
#     location /vendor/telescope/ {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri \$uri/ /index.php\$is_args$args;
#     }
#
#     location ~ ^/(api/v2/) {
#         proxy_pass      http://127.0.0.1:3333;
#         proxy_redirect off;
#         proxy_http_version 1.1;
#         proxy_set_header Host \$host;
#         proxy_set_header X-Real-IP \$remote_addr;
#         proxy_set_header Upgrade \$http_upgrade;
#         proxy_set_header Connection "upgrade";
#         proxy_set_header X-Forwarded-Proto \$scheme;
#         proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
#         proxy_cache_bypass \$http_upgrade;
#     }
#
#     location ~ ^/(api/v1/|horizon|telescope|pulse|livewire) {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri /index.php =404;
#         fastcgi_pass php-upstream-81;
#         fastcgi_index index.php;
#         fastcgi_buffers 16 16k;
#         fastcgi_buffer_size 32k;
#         fastcgi_param SCRIPT_FILENAME \$document_root$fastcgi_script_name;
#         fastcgi_read_timeout 600;
#         include fastcgi_params;
#     }
#
#     location / {
#         proxy_pass http://127.0.0.1:8081;
#         proxy_set_header   Host              \$host;
#         proxy_set_header   X-Real-IP         \$remote_addr;
#         proxy_set_header   X-Forwarded-For   \$proxy_add_x_forwarded_for;
#         proxy_set_header   X-Forwarded-Proto \$scheme;
#         proxy_set_header   X-Client-Verify   SUCCESS;
#         proxy_set_header   X-Client-DN       \$ssl_client_s_dn;
#         proxy_set_header   X-SSL-Subject     \$ssl_client_s_dn;
#         proxy_set_header   X-SSL-Issuer      \$ssl_client_i_dn;
#         proxy_set_header   X-NginX-Proxy true;
#         proxy_set_header   Upgrade \$http_upgrade;
#         proxy_set_header   Connection "upgrade";
#         proxy_http_version 1.1;
#         proxy_read_timeout 1800;
#         proxy_connect_timeout 1800;
#         chunked_transfer_encoding on;
#         proxy_redirect off;
#         proxy_buffering off;
#     }
#
#     location ~ /\.ht {
#         deny all;
#     }
# }
#
# server {
#     listen 127.0.0.1:60;
#     server_name $DOMAIN www.$DOMAIN *.$DOMAIN;
#     root /;
#     charset utf-8;
#     client_max_body_size 1024M;
#
#     add_header X-Robots-Tag 'noindex, nofollow, nosnippet, noarchive';
#
#     location /41c270e4-5535-4daa-b23e-c269744c2f45/ {
#         internal;
#         alias /;
#         try_files \$uri \$uri/;
#     }
#
#     access_log off;
#     error_log "/Users/owrasor/Library/Application Support/Herd/Log/$DOMAIN-error.log";
#
#     error_page 404 "";
#
#     location /vendor/horizon/ {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri \$uri/ /index.php\$is_args$args;
#     }
#
#     location /vendor/telescope/ {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri \$uri/ /index.php\$is_args$args;
#     }
#
#     location ~ ^/(api/v2/) {
#         proxy_pass      http://127.0.0.1:3333;
#         proxy_redirect off;
#         proxy_http_version 1.1;
#         proxy_set_header Host \$host;
#         proxy_set_header X-Real-IP \$remote_addr;
#         proxy_set_header Upgrade \$http_upgrade;
#         proxy_set_header Connection "upgrade";
#         proxy_set_header X-Forwarded-Proto \$scheme;
#         proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
#         proxy_cache_bypass \$http_upgrade;
#     }
#
#     location ~ ^/(api/v1/|horizon|telescope|pulse|livewire) {
#         root /var/www/html/aprovafacil-webserver/public;
#         index index.php;
#         try_files \$uri /index.php =404;
#         fastcgi_pass php-upstream-81;
#         fastcgi_index index.php;
#         fastcgi_buffers 16 16k;
#         fastcgi_buffer_size 32k;
#         fastcgi_param SCRIPT_FILENAME \$document_root$fastcgi_script_name;
#         fastcgi_read_timeout 600;
#         include fastcgi_params;
#     }
#
#     location / {
#         proxy_pass http://127.0.0.1:8081;
#         proxy_set_header   Host              \$host;
#         proxy_set_header   X-Real-IP         \$remote_addr;
#         proxy_set_header   X-Forwarded-For   \$proxy_add_x_forwarded_for;
#         proxy_set_header   X-Forwarded-Proto \$scheme;
#     }
#
#     location ~ /\.ht {
#         deny all;
#     }
# }
# EOF
#
#     chmod 644 "$NEW_CONFIG"
#
#     echo "Nginx configuration for $DOMAIN has been created at $NEW_CONFIG"
#
#     echo "Reiniciando Nginx via Herd..."
#     herd restart nginx
#     echo "Nginx restarted"
# }

# Create a new host at /etc/hosts for Aprovafacil Project
function add_aprova_host() {
    if [ $# -ne 1 ]; then
        echo "Usage: add_aprova_host <hostname>"
        return 1
    fi

    local hostname="$1.aprovafacil.test"
    local ip="127.0.0.1"  # Assuming you want to add a localhost entry

    eval "add_host '$ip' '$hostname'"
}

function remove_host() {
    if [ $# -ne 1 ]; then
        echo "Usage: remove_host <hostname>"
        return 1
    fi

    local hostname=$1

    if [ -n "$(grep $hostname /etc/hosts)" ]; then
        sudo grep -vE "\\b$hostname\\b" /etc/hosts | sudo tee /etc/hosts.tmp >/dev/null
        sudo mv /etc/hosts.tmp /etc/hosts
        if [ -n "$(grep $hostname /etc/hosts)" ]; then
            echo "Entry for $hostname failed to be from /etc/hosts"
        else
            echo "Entry for $hostname removed from /etc/hosts"
         fi
    else
        echo "Hostname $hostname does not exists to be removed"
    fi
}

function remove_aprova_host() {
    if [ $# -ne 1 ]; then
        echo "Usage: remove_aprova_host <hostname>"
        return 1
    fi

    local hostname="$1.aprovafacil.test"

    eval "remove_host '$hostname'"
}

function restore_aprova_db() {
    local local_exec=0
    local convert_encoding=0

    while [[ $1 == -* ]]; do
        case $1 in
            -wd) local_exec=1 ;;
            -c)  convert_encoding=1 ;;
            *)   echo "Unknown option: $1"; return 1 ;;
        esac
        shift
    done

    if [ $# -lt 2 ]; then
        echo "Usage: restore_aprova_db [-wd] [-c] <database> <file_location> [user] [host] [port]"
        echo "  -wd: Execute locally (default: Docker)"
        echo "  -c:  Convert dump from UTF8 to LATIN1"
        return 1
    fi

    local database=$1
    local file_location=$2
    local db_user=${3:-homestead}
    local db_host=$4
    local db_port=$5

    local host_arg=""
    if [ -n "$db_host" ]; then
        host_arg="-h $db_host"
    fi

    local port_arg=""
    if [ -n "$db_port" ]; then
        port_arg="-p $db_port"
    fi

    # Prompt for password once if not set
    local PGPASSWORD=$PGPASSWORD
    if [[ -z "$PGPASSWORD" ]]; then
        echo -n "Database password for $db_user: "
        read -rs PGPASSWORD
        echo
    fi
    export PGPASSWORD

    echo "Starting database restore for: $database"
    echo "File location: $file_location"
    echo "User: $db_user"
    [ -n "$db_host" ] && echo "Host: $db_host"
    [ -n "$db_port" ] && echo "Port: $db_port"
    [ $convert_encoding -eq 1 ] && echo "Encoding conversion: UTF-8 -> LATIN1"

    # Encoding configuration
    local encoding_filter="cat \"$file_location\""
    if [ $convert_encoding -eq 1 ]; then
        encoding_filter="$encoding_filter | iconv -f UTF-8 -t LATIN1//TRANSLIT"
        export PGCLIENTENCODING=LATIN1
    else
        export PGCLIENTENCODING=UTF8
    fi

    local common_filter="sed -E '/^ALTER.*OWNER TO/d; /^GRANT/d; /^REVOKE/d'"

    if [ $local_exec -eq 1 ]; then
        echo "Executing locally..."
        
        # Verifica se o banco existe
        if psql -U "$db_user" $host_arg $port_arg -d postgres -lqt | cut -d \| -f 1 | grep -qw "$database"; then
            echo "Database $database exists. Terminating connections..."
            psql -U "$db_user" $host_arg $port_arg -d postgres -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$database' AND pid <> pg_backend_pid();"
            
            echo "Dropping database $database..."
            if dropdb -U "$db_user" $host_arg $port_arg "$database"; then
                echo "Database $database dropped successfully."
            else
                echo "Error: Failed to drop database $database"
                return 1
            fi
        else
            echo "Database $database does not exist."
        fi
        
        echo "Creating database $database..."
        if createdb -U "$db_user" $host_arg $port_arg "$database"; then
            echo "Database $database created successfully."
        else
            echo "Error: Failed to create database $database"
            return 1
        fi
        
        echo "Restoring data to $database..."
        if eval "$encoding_filter | $common_filter | psql -U \"$db_user\" $host_arg $port_arg -d \"$database\""; then
            echo "Database restore completed successfully!"
        else
            echo "Error: Failed to restore data to database $database"
            return 1
        fi
    else
        echo "Executing via Docker..."
        
        # Helper function to run commands with PGPASSWORD inside docker
        function dc_psql() {
            eval "dc exec -T -e PGPASSWORD=\"$PGPASSWORD\" -e PGCLIENTENCODING=\"$PGCLIENTENCODING\" postgres $@"
        }

        # Verifica se o banco existe
        if dc_psql psql -U $db_user $host_arg $port_arg -d postgres -lqt | cut -d \| -f 1 | grep -qw $database; then
            echo "Database $database exists. Terminating connections..."
            dc_psql psql -U $db_user $host_arg $port_arg -d postgres -c "\"SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$database' AND pid <> pg_backend_pid();\""
            
            echo "Dropping database $database..."
            if dc_psql dropdb -U $db_user $host_arg $port_arg $database; then
                echo "Database $database dropped successfully."
            else
                echo "Error: Failed to drop database $database"
                return 1
            fi
        else
            echo "Database $database does not exist."
        fi
        
        echo "Creating database $database..."
        if dc_psql createdb -U $db_user $host_arg $port_arg $database; then
            echo "Database $database created successfully."
        else
            echo "Error: Failed to create database $database"
            return 1
        fi
        
        echo "Restoring data to $database..."
        if eval "$encoding_filter | $common_filter | dc exec -T -e PGPASSWORD=\"$PGPASSWORD\" -e PGCLIENTENCODING=\"$PGCLIENTENCODING\" postgres psql -U $db_user $host_arg $port_arg -d $database"; then
            echo "Database restore completed successfully!"
        else
            echo "Error: Failed to restore data to database $database"
            return 1
        fi
    fi
}

#--------------------------------------------------------------------------
# Laravel artisan plugin for zsh
#--------------------------------------------------------------------------
#
# This plugin adds an `artisan` shell command that will find and execute
# Laravel's artisan command from anywhere within the project. It also
# adds shell completions that work anywhere artisan can be located.

function artisan() {
    local artisan_path=`_artisan_find`

    if [ "$artisan_path" = "" ]; then
        >&2 echo "zsh-artisan: artisan not found. Are you in a Laravel directory?"
        return 1
    fi

    local laravel_path=`dirname $artisan_path`
    local docker_compose_config_path=`find $laravel_path -maxdepth 1 \( -name "docker-compose.yml" -o -name "docker-compose.yaml" \) | head -n1`
    local artisan_cmd

    artisan_cmd="php $artisan_path"

    if [ "$docker_compose_config_path" != '' ]; then
        if [ "`grep -i "image: sail-.*/app.*$" $docker_compose_config_path | grep -v "#.*image: sail-.*/app.*$" | head -n1`" != '' ]; then
            artisan_cmd="$laravel_path/vendor/bin/sail artisan"
        else
            local docker_compose_service_name=`docker-compose ps --services 2>/dev/null | grep 'app\|php\|api\|workspace\|laravel\.test\|webhost' | head -n1`
            if [ "$docker_compose_service_name" != '' ]; then
                if [ -t 1 ]; then
                    artisan_cmd="docker-compose exec $docker_compose_service_name php artisan"
                else
                    # The command is not being run in a TTY (e.g. it's being called by the completion handler below)
                    artisan_cmd="docker-compose exec -T $docker_compose_service_name php artisan"
                fi
            fi
        fi
    fi

    local artisan_subcmd=$1
    shift

    local artisan_args=()
    local arg
    for arg in $@
    do
        artisan_args+=($(printf "%s" "$arg" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"))
    done

    local artisan_start_time=`date +%s`

    eval $artisan_cmd $artisan_subcmd $artisan_args

    local artisan_exit_status=$? # Store the exit status so we can return it later

    if [[ $1 = "make:"* && $ARTISAN_OPEN_ON_MAKE_EDITOR != "" ]]; then
        # Find and open files created by artisan
        find \
            "$laravel_path/app" \
            "$laravel_path/tests" \
            "$laravel_path/database" \
            -type f \
            -newermt "-$((`date +%s` - $artisan_start_time + 1)) seconds" \
            -exec $ARTISAN_OPEN_ON_MAKE_EDITOR {} \; 2>/dev/null
    fi

    return $artisan_exit_status
}

# compdef _artisan_add_completion artisan

function _artisan_find() {
    # Look for artisan up the file tree until the root directory
    local dir=.
    until [ $dir -ef / ]; do
        if [ -f "$dir/artisan" ]; then
            echo "$dir/artisan"
            return 0
        fi

        dir+=/..
    done

    return 1
}

function _artisan_add_completion() {
    if [ "`_artisan_find`" != "" ]; then
        compadd `_artisan_get_command_list`
    fi
}

function _artisan_get_command_list() {
    artisan --raw --no-ansi list | sed "s/[[:space:]].*//g"
}

function _docker_compose_cmd() {
    docker compose &> /dev/null
    if [ $? = 0 ]; then
        echo "docker compose"
    else
        echo "docker-compose"
    fi
}

function _t() {
  {
    exec </dev/tty
    exec <&1
    local session
    session=$(sesh list -t -c | fzf --height 40% --reverse --border-label ' sesh ' --border --prompt '⚡  ')
    [[ -z "$session" ]] && return
    sesh connect $session
  }
}

open () {
    xdg-open $* > /dev/null 2>&1
}

composer-link() {
    composer config repositories.local '{"type": "path", "url": "'$1'"}' --file composer.json
}

# Restore a PostgreSQL database dump using standard psql credentials
restore_db() {
    local use_docker=0
    local container_name="postgres"

    if [[ "$1" == "-wd" ]]; then
        use_docker=1
        shift
    fi

    if [[ $# -ne 2 ]]; then
        echo "Usage: restore_pg [-wd] <database> <dump_path>"
        return 1
    fi

    if (( ! use_docker )) && ! command -v psql >/dev/null 2>&1; then
        echo "psql command not found"
        return 1
    fi

    local db_name="$1"
    local dump_path="$2"

    if [[ ! -f "$dump_path" ]]; then
        echo "Dump file not found: $dump_path"
        return 1
    fi

    local -a psql_cmd
    local -a psql_restore_cmd

    if (( use_docker )); then
        if ! command -v docker >/dev/null 2>&1; then
            echo "docker command not found"
            return 1
        fi

        local resolved_container="$container_name"

        if ! docker ps --format '{{.Names}}' | grep -Fx "$resolved_container" >/dev/null 2>&1; then
            resolved_container="$(docker ps --filter "label=com.docker.compose.service=${container_name}" --format '{{.Names}}' | head -n 1)"

            if [[ -z "$resolved_container" ]]; then
                resolved_container="$(docker ps --filter "name=${container_name}" --format '{{.Names}}' | head -n 1)"
            fi

            if [[ -z "$resolved_container" ]]; then
                resolved_container="$(docker ps --filter "ancestor=${container_name}" --format '{{.Names}}' | head -n 1)"
            fi

            if [[ -z "$resolved_container" && "$container_name" != "postgres" ]]; then
                resolved_container="$(docker ps --filter "ancestor=postgres" --format '{{.Names}}' | head -n 1)"
            fi

            if [[ -z "$resolved_container" ]]; then
                echo "Running container not found matching identifier: $container_name"
                return 1
            fi
        fi

        resolved_container="${resolved_container//$'\n'/}"

        psql_cmd=(docker exec -i "$resolved_container" env PGPASSWORD="secret" psql --username=homestead --set=ON_ERROR_STOP=on)
        psql_restore_cmd=(docker exec -i "$resolved_container" env PGPASSWORD="secret" psql --username=homestead --set=ON_ERROR_STOP=off)
    else
        psql_cmd=(env PGPASSWORD="secret" psql --username=homestead --set=ON_ERROR_STOP=on)
        psql_restore_cmd=(env PGPASSWORD="secret" psql --username=homestead --set=ON_ERROR_STOP=off)
    fi

    local admin_db="postgres"
    local escaped_db_literal="${db_name//\'/''}"
    local escaped_db_identifier="${db_name//\"/\"\"}"
    local db_exists_output

    if ! db_exists_output="$("${psql_cmd[@]}" --dbname="$admin_db" --tuples-only --no-align --command "SELECT 1 FROM pg_database WHERE datname = '${escaped_db_literal}'")"; then
        echo "Failed to verify database existence: $db_name"
        return 1
    fi

    local db_exists="${db_exists_output//$'\n'/}"

    if [[ "$db_exists" == "1" ]]; then
        local terminate_query="SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '${escaped_db_literal}' AND pid <> pg_backend_pid();"

        if ! "${psql_cmd[@]}" --dbname="$admin_db" --command "$terminate_query"; then
            echo "Failed to terminate active sessions for database: $db_name"
            return 1
        fi

        if ! "${psql_cmd[@]}" --dbname="$admin_db" --command "DROP DATABASE \"${escaped_db_identifier}\";"; then
            echo "Failed to drop existing database: $db_name"
            return 1
        fi
    fi

    if ! "${psql_cmd[@]}" --dbname="$admin_db" --command "CREATE DATABASE \"${escaped_db_identifier}\";"; then
        echo "Failed to create database: $db_name"
        return 1
    fi

    if (( use_docker )); then
        if ! "${psql_restore_cmd[@]}" --dbname="$db_name" < "$dump_path"; then
            echo "Restore failed inside container ${resolved_container:-$container_name}"
            return 1
        fi
    else
        if ! "${psql_restore_cmd[@]}" --dbname="$db_name" --file="$dump_path"; then
            echo "Restore failed for database $db_name"
            return 1
        fi
    fi
}

#--------------------------------------------------------------------------
# Miscellaneous
#--------------------------------------------------------------------------

### Fix slowness of pastes with zsh-syntax-highlighting.zsh
pasteinit() {
  OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}
  zle -N self-insert url-quote-magic # I wonder if you'd need `.url-quote-magic`?
}

pastefinish() {
  zle -N self-insert $OLD_SELF_INSERT
}
zstyle :bracketed-paste-magic paste-init pasteinit
zstyle :bracketed-paste-magic paste-finish pastefinish
### Fix slowness of pastes

### Added by Zinit's installer
if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    print -P "%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$HOME/.local/share/zinit" && command chmod g-rwX "$HOME/.local/share/zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.local/share/zinit/zinit.git" && \
        print -P "%F{33} %F{34}Installation successful.%f%b" || \
        print -P "%F{160} The clone has failed.%f%b"
fi

source "$HOME/.local/share/zinit/zinit.git/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit

# Load a few important annexes, without Turbo
# (this is currently required for annexes)
zinit light-mode for \
    zdharma-continuum/zinit-annex-as-monitor \
    zdharma-continuum/zinit-annex-bin-gem-node \
    zdharma-continuum/zinit-annex-patch-dl \
    zdharma-continuum/zinit-annex-rust

### End of Zinit's installer chunk
zinit light zdharma/fast-syntax-highlighting
zinit light zsh-users/zsh-autosuggestions
zinit light zsh-users/zsh-completions

export PATH="$PATH:/opt/nvim-linux-x86_64/bin:/usr/local/go/bin"

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# opencode
export PATH=/home/owrasor/.opencode/bin:$PATH

export PATH="${ASDF_DATA_DIR:-$HOME/Apps/asdf}/bin:$PATH"

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
source ~/powerlevel10k/powerlevel10k.zsh-theme

# Tmuxinator Auto-start
if [[ -z "$TMUX" && -n "$PS1" ]]; then
    tmuxinator start aprovafacil
fi
